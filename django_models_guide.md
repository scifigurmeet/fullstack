# Django Models, Migrations & Admin - Step by Step Guide

Let's learn Django models, database operations, and admin interface from the ground up!

## What We'll Learn
- **Models**: How Django represents database tables as Python classes
- **Migrations**: How Django tracks and applies database changes
- **ORM**: Object-Relational Mapping - working with database using Python objects
- **Django Admin**: Built-in interface for managing data
- **Relationships**: Connecting different models together

## Initial Setup

```bash
django-admin startproject blogproject
cd blogproject
python manage.py startapp blog
```

Add to `blogproject/settings.py`:
```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'blog',  # Add this
]
```

---

## Step 1: Understanding Models

**What is a Model?**
A model in Django is a Python class that represents a database table. Each attribute of the model represents a database field.

### Create your first model in `blog/models.py`:
```python
from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    
    def __str__(self):
        return self.title
```

**What this means:**
- `Post` class = database table named "blog_post"
- `title` = VARCHAR(200) column in database
- `content` = TEXT column in database
- `created_at` = DATETIME column that auto-sets when created
- `__str__()` method = how object displays as text

**Don't run anything yet!** Let's understand migrations first.

---

## Step 2: Understanding Migrations

**What are Migrations?**
Migrations are Django's way of tracking changes to your models and applying them to your database. Think of them as version control for your database schema.

### Create your first migration:
```bash
python manage.py makemigrations
```

You'll see output like:
```
Migrations for 'blog':
  blog/migrations/0001_initial.py
    - Create model Post
```

**What happened?**
Django created a migration file that contains instructions to create the Post table.

### Look at the migration file `blog/migrations/0001_initial.py`:
```python
# Generated by Django
from django.db import migrations, models

class Migration(migrations.Migration):
    initial = True
    dependencies = []

    operations = [
        migrations.CreateModel(
            name='Post',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=200)),
                ('content', models.TextField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
        ),
    ]
```

**Notice:** Django automatically adds an `id` field as primary key!

### Apply the migration to create the actual database table:
```bash
python manage.py migrate
```

You'll see:
```
Operations to perform:
  Apply all migrations: admin, auth, blog, contenttypes, sessions
Running migrations:
  Applying blog.0001_initial... OK
```

**What happened?** Django created the actual database table based on your model.

---

## Step 3: Django Shell - Exploring Models with ORM

**What is ORM?**
Object-Relational Mapping (ORM) lets you work with databases using Python objects instead of writing SQL queries.

### Start Django shell:
```bash
python manage.py shell
```

### Create your first post:
```python
# Import your model
from blog.models import Post

# Create a new post (INSERT)
post1 = Post(title="My First Post", content="This is my first blog post!")
post1.save()  # This saves to database

# Or create and save in one step
post2 = Post.objects.create(
    title="Second Post", 
    content="This is my second post!"
)

print(f"Created post: {post1}")
print(f"Post ID: {post1.id}")
print(f"Created at: {post1.created_at}")
```

### Read data from database (SELECT):
```python
# Get all posts
all_posts = Post.objects.all()
print(f"Total posts: {all_posts.count()}")

# Loop through posts
for post in all_posts:
    print(f"- {post.title}")

# Get specific post by ID
first_post = Post.objects.get(id=1)
print(f"First post: {first_post.title}")

# Filter posts
posts_with_first = Post.objects.filter(title__contains="First")
print(f"Posts with 'First': {posts_with_first}")
```

### Update data (UPDATE):
```python
# Get a post and update it
post = Post.objects.get(id=1)
post.title = "My Updated First Post"
post.save()
print(f"Updated title: {post.title}")

# Or update multiple records
Post.objects.filter(title__contains="Second").update(content="Updated content!")
```

### Delete data (DELETE):
```python
# Delete a specific post
post_to_delete = Post.objects.get(id=2)
post_to_delete.delete()

# Or delete multiple
# Post.objects.filter(title__contains="test").delete()

print(f"Remaining posts: {Post.objects.count()}")
```

### Exit shell:
```python
exit()
```

**What you learned:**
- `objects.create()` = INSERT INTO
- `objects.all()` = SELECT * FROM
- `objects.get()` = SELECT with specific condition
- `objects.filter()` = SELECT with WHERE clause
- `save()` = UPDATE existing record
- `delete()` = DELETE FROM

---

## Step 4: Adding More Model Features

Let's make our model more realistic by adding more fields and validation.

### Update `blog/models.py`:
```python
from django.db import models
from django.core.validators import MinLengthValidator

class Post(models.Model):
    # Field choices
    STATUS_CHOICES = [
        ('draft', 'Draft'),
        ('published', 'Published'),
        ('archived', 'Archived'),
    ]
    
    title = models.CharField(
        max_length=200,
        validators=[MinLengthValidator(5, "Title must be at least 5 characters")]
    )
    slug = models.SlugField(max_length=200, unique=True, help_text="URL-friendly version of title")
    content = models.TextField()
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='draft')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['-created_at']  # Order by newest first
        verbose_name = "Blog Post"
        verbose_name_plural = "Blog Posts"
    
    def __str__(self):
        return f"{self.title} ({self.status})"
```

### Create and apply migration:
```bash
python manage.py makemigrations
```

Django will ask about default values for existing records:
```
You are trying to add a non-nullable field 'slug' to post without a default...
Select an option:
1) Provide a one-off default now
2) Quit, and let me add a default in models.py
```

Choose option 1 and enter: `temp-slug`

```bash
python manage.py migrate
```

### Test in shell:
```bash
python manage.py shell
```

```python
from blog.models import Post

# Create post with new fields
post = Post.objects.create(
    title="Django Models Guide",
    slug="django-models-guide",
    content="Learning Django models step by step",
    status="published"
)

# Test choices
print(f"Status: {post.status}")
print(f"Status display: {post.get_status_display()}")

# Test ordering
posts = Post.objects.all()
for post in posts:
    print(f"{post.title} - {post.created_at}")

exit()
```

---

## Step 5: Models with Foreign Keys (Relationships)

**What are Foreign Keys?**
Foreign keys create relationships between models. Like connecting authors to their blog posts.

### Add Author model to `blog/models.py`:
```python
from django.db import models
from django.core.validators import MinLengthValidator

class Author(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    email = models.EmailField(unique=True)
    bio = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    def __str__(self):
        return f"{self.first_name} {self.last_name}"
    
    @property
    def full_name(self):
        return f"{self.first_name} {self.last_name}"

class Category(models.Model):
    name = models.CharField(max_length=100, unique=True)
    description = models.TextField(blank=True)
    
    class Meta:
        verbose_name_plural = "Categories"
    
    def __str__(self):
        return self.name

class Post(models.Model):
    STATUS_CHOICES = [
        ('draft', 'Draft'),
        ('published', 'Published'),
        ('archived', 'Archived'),
    ]
    
    title = models.CharField(
        max_length=200,
        validators=[MinLengthValidator(5, "Title must be at least 5 characters")]
    )
    slug = models.SlugField(max_length=200, unique=True)
    content = models.TextField()
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='draft')
    
    # Foreign Key relationships
    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='posts')
    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True, blank=True)
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = "Blog Post"
        verbose_name_plural = "Blog Posts"
    
    def __str__(self):
        return f"{self.title} by {self.author}"
```

### Create and apply migration:
```bash
python manage.py makemigrations
python manage.py migrate
```

### Test relationships in shell:
```bash
python manage.py shell
```

```python
from blog.models import Author, Category, Post

# Create author
author = Author.objects.create(
    first_name="John",
    last_name="Doe", 
    email="john@example.com",
    bio="A passionate writer"
)

# Create category
category = Category.objects.create(
    name="Technology",
    description="Posts about technology"
)

# Create post with relationships
post = Post.objects.create(
    title="Learning Django Models",
    slug="learning-django-models",
    content="This post explains Django models...",
    status="published",
    author=author,
    category=category
)

# Access related objects
print(f"Post author: {post.author.full_name}")
print(f"Post category: {post.category.name}")

# Reverse relationships
print(f"Author's posts: {author.posts.all()}")
print(f"Posts count: {author.posts.count()}")

# Filter by relationships
tech_posts = Post.objects.filter(category__name="Technology")
john_posts = Post.objects.filter(author__first_name="John")

print(f"Tech posts: {tech_posts.count()}")
print(f"John's posts: {john_posts.count()}")

exit()
```

**What you learned:**
- `ForeignKey` creates relationships between models
- `on_delete=models.CASCADE` = delete posts when author is deleted
- `on_delete=models.SET_NULL` = set to null when category is deleted
- `related_name='posts'` = access author's posts with `author.posts.all()`
- Double underscore `__` for filtering across relationships

---

## Step 6: Django Admin Interface

**What is Django Admin?**
Django Admin is a built-in interface for managing your data. Perfect for content management!

### Create superuser:
```bash
python manage.py createsuperuser
```

Enter username, email, and password when prompted.

### Register models in `blog/admin.py`:
```python
from django.contrib import admin
from .models import Author, Category, Post

# Simple registration
admin.site.register(Author)
admin.site.register(Category)
admin.site.register(Post)
```

### Start server and visit admin:
```bash
python manage.py runserver
```

Visit: http://127.0.0.1:8000/admin/

Login with your superuser credentials. You can now:
- Add, edit, delete authors, categories, and posts
- See all your data in a nice interface
- Use search and filters

---

## Step 7: Customizing Django Admin

Let's make the admin interface more powerful and user-friendly.

### Update `blog/admin.py`:
```python
from django.contrib import admin
from .models import Author, Category, Post

@admin.register(Author)
class AuthorAdmin(admin.ModelAdmin):
    list_display = ['first_name', 'last_name', 'email', 'created_at']
    list_filter = ['created_at']
    search_fields = ['first_name', 'last_name', 'email']
    ordering = ['last_name', 'first_name']

@admin.register(Category)
class CategoryAdmin(admin.ModelAdmin):
    list_display = ['name', 'description']
    search_fields = ['name']
    prepopulated_fields = {'description': ('name',)}

@admin.register(Post)
class PostAdmin(admin.ModelAdmin):
    list_display = ['title', 'author', 'category', 'status', 'created_at']
    list_filter = ['status', 'category', 'created_at', 'author']
    search_fields = ['title', 'content']
    prepopulated_fields = {'slug': ('title',)}
    list_editable = ['status']
    date_hierarchy = 'created_at'
    
    fieldsets = (
        ('Basic Information', {
            'fields': ('title', 'slug', 'author', 'category')
        }),
        ('Content', {
            'fields': ('content', 'status')
        }),
        ('Timestamps', {
            'fields': ('created_at', 'updated_at'),
            'classes': ('collapse',)
        })
    )
    readonly_fields = ['created_at', 'updated_at']
```

### Visit admin again to see improvements:
- Better list views with multiple columns
- Filters and search functionality
- Organized form fields in sections
- Auto-slug generation from title

---

## Step 8: Users, Groups, and Permissions

**What are Django's built-in User features?**
Django includes user authentication, groups, and permissions system out of the box.

### Explore in Django shell:
```bash
python manage.py shell
```

```python
from django.contrib.auth.models import User, Group, Permission
from django.contrib.contenttypes.models import ContentType
from blog.models import Post

# Create a new user
user = User.objects.create_user(
    username='editor',
    email='editor@example.com',
    password='editorsecret123',
    first_name='Jane',
    last_name='Editor'
)

# Create a group
editors_group = Group.objects.create(name='Editors')

# Add user to group
user.groups.add(editors_group)

# Get specific permissions
content_type = ContentType.objects.get_for_model(Post)
permissions = Permission.objects.filter(content_type=content_type)

print("Available permissions for Post model:")
for perm in permissions:
    print(f"- {perm.codename}: {perm.name}")

# Add permissions to group
can_add_post = Permission.objects.get(codename='add_post')
can_change_post = Permission.objects.get(codename='change_post')

editors_group.permissions.add(can_add_post, can_change_post)

# Check user permissions
print(f"User can add posts: {user.has_perm('blog.add_post')}")
print(f"User can change posts: {user.has_perm('blog.change_post')}")
print(f"User can delete posts: {user.has_perm('blog.delete_post')}")

exit()
```

### Login as different user in admin:
1. Logout from admin
2. Login as 'editor' with password 'editorsecret123'
3. Notice limited permissions - can only add/edit posts, not delete

---

## Step 9: Database Configuration

**What about different databases?**
Django supports multiple databases. Let's see how to configure them.

### Current database (SQLite) in `blogproject/settings.py`:
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```

### PostgreSQL configuration example:
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'myblog',
        'USER': 'bloguser',
        'PASSWORD': 'password',
        'HOST': 'localhost',
        'PORT': '5432',
    }
}
```

### MySQL configuration example:
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'myblog',
        'USER': 'bloguser',
        'PASSWORD': 'password',
        'HOST': 'localhost',
        'PORT': '3306',
        'OPTIONS': {
            'sql_mode': 'traditional',
        }
    }
}
```

### Multiple databases example:
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    },
    'users_db': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'users',
        'USER': 'userapp',
        'PASSWORD': 'password',
        'HOST': 'localhost',
        'PORT': '5432',
    }
}
```

**Note:** For this tutorial, stick with SQLite - it's perfect for learning!

---

## Step 10: Advanced ORM Queries

Let's explore more powerful database operations.

### Create some test data first:
```bash
python manage.py shell
```

```python
from blog.models import Author, Category, Post

# Create more authors
author1 = Author.objects.create(first_name="Alice", last_name="Smith", email="alice@example.com")
author2 = Author.objects.create(first_name="Bob", last_name="Johnson", email="bob@example.com")

# Create more categories
cat1 = Category.objects.create(name="Programming", description="Programming tutorials")
cat2 = Category.objects.create(name="Design", description="Design articles")

# Create more posts
Post.objects.create(title="Python Basics", slug="python-basics", content="Learn Python...", 
                   author=author1, category=cat1, status="published")
Post.objects.create(title="Django Tutorial", slug="django-tutorial", content="Learn Django...", 
                   author=author1, category=cat1, status="draft")
Post.objects.create(title="UI Design Tips", slug="ui-design-tips", content="Design better UIs...", 
                   author=author2, category=cat2, status="published")

# Advanced queries
from django.db.models import Count, Q
from datetime import datetime, timedelta

# Count posts per author
authors_with_counts = Author.objects.annotate(post_count=Count('posts'))
for author in authors_with_counts:
    print(f"{author}: {author.post_count} posts")

# Complex filtering with Q objects
recent_published = Post.objects.filter(
    Q(status='published') & 
    Q(created_at__gte=datetime.now() - timedelta(days=30))
)

# Posts by multiple authors
posts_by_alice_or_bob = Post.objects.filter(
    Q(author__first_name='Alice') | Q(author__first_name='Bob')
)

# Exclude certain posts
non_draft_posts = Post.objects.exclude(status='draft')

# Select related (joins) - more efficient
posts_with_authors = Post.objects.select_related('author', 'category')
for post in posts_with_authors:
    print(f"{post.title} by {post.author} in {post.category}")

# Order by multiple fields
posts_ordered = Post.objects.order_by('-created_at', 'title')

print(f"Recent published posts: {recent_published.count()}")
print(f"Posts by Alice or Bob: {posts_by_alice_or_bob.count()}")
print(f"Non-draft posts: {non_draft_posts.count()}")

exit()
```

---

## Summary: What You've Learned

### 1. **Models** 📋
- Models are Python classes that represent database tables
- Each field type maps to a database column type
- `__str__()` method controls how objects display

### 2. **Migrations** 🔄
- `makemigrations` creates migration files
- `migrate` applies changes to database
- Migrations track all database schema changes

### 3. **Django ORM** 🔍
- Work with databases using Python objects, not SQL
- `objects.create()`, `objects.all()`, `objects.filter()`, etc.
- Query across relationships with double underscores

### 4. **Relationships** 🔗
- `ForeignKey` creates one-to-many relationships
- `on_delete` controls what happens when referenced object is deleted
- `related_name` provides reverse relationship access

### 5. **Django Admin** ⚙️
- Built-in interface for data management
- Customizable with `ModelAdmin` classes
- Perfect for content management and testing

### 6. **Users & Permissions** 👥
- Built-in User, Group, and Permission models
- Granular permissions per model and operation
- Easy integration with your models

### 7. **Database Configuration** 🗄️
- Support for SQLite, PostgreSQL, MySQL, and more
- Easy configuration in settings.py
- Multiple database support available

## Project Structure
```
blogproject/
├── manage.py
├── blogproject/
│   ├── settings.py
│   ├── urls.py
│   └── ...
└── blog/
    ├── models.py          # Your data models
    ├── admin.py           # Admin customization
    ├── migrations/        # Database change history
    │   ├── 0001_initial.py
    │   └── ...
    └── ...
```

## Next Steps
- Add Many-to-Many relationships (tags for posts)
- Create custom model methods
- Learn about model inheritance
- Explore Django REST framework for APIs

You now have a solid foundation in Django's data layer! 🎉